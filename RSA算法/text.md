**RSA算法**

**数学基础：**
- 互质关系:
如果两个正整数，除了1以外，没有其他公因子，我们就称这两个数是互质关系 

- 任意两个质数构成互质关系：
  -  一个数是质数，另一个数只要不是前者的倍数，两者就构成互质关系
  -  1和任意一个自然数是都是互质关系
  -  p是大于1的整数，则p和p-1构成互质关系
  -  p是大于1的奇数，则p和p-2构成互质关系

- 欧拉函数:
在小于等于n的正整数之中，能与n构成互质关系的数的个数，计算这个值的方法叫做欧拉函数，以φ(n)表示
  -  如果n=1，则 φ(1) = 1 。因为1与任何数（包括自身）都构成互质关系
  -  如果n是质数，则 φ(n)=n-1 。因为质数与小于它的每一个数，都构成互质关系
  -  如果n是质数的某一个次方，即 n = p^k (p为质数，k为大于等于1的整数)
    φ(p^k^) = p^k^ - p^k-1^
  -  如果n可以分解成两个互质的整数之积，即n = p1 × p2
     则φ(n) = φ(p1 × p2) = φ(p1) × φ(p2)

- 欧拉定理:
如果两个正整数a和n互质，则n的欧拉函数 φ(n) 可以让下面的等式成立：
     a^φ(n)^≡1(mod n)

- 费马小定理：
假设正整数a与质数p互质，因为质数p的φ(p)等于p-1，则欧拉定理可以写成
     a^p-1^≡1(mod p)

- 模反元素:
如果两个正整数a和n互质，那么一定可以找到整数b，使得 ab-1 被n整除，或者说ab被n除的余数是1。
ab≡1(mod n)

这时候b就叫做a的”模反元素”

**RSA算法基本概念**
- RSA加密
  - 密文 = 明文^E^mod N
  - 公钥 = (E,N)

- RSA解密
  - 明文 = 密文^D^modN
  - 私钥 = (D,N)

![image](http://91wxk.cn/usr/uploads/2021/04/1646083762.png)

**生成密钥对过程**

1.随机找两个质数p和q，p和q越大越安全，计算他们的乘积n=p*q

实际算法中p和q的乘积转化为二进制为1024位或2048位，位数越长，算法越难被破解

2.计算n的欧拉函数 L = φ(n)
φ(n)表示在小于等于n的正整数之中，与n构成互质关系的数的个数。

互质关系：互质是公约数只有1的两个整数。

φ(n) = φ(pq) = φ(p)xφ(q) = (p-1)*(q-1)

**利用了欧拉函数的特殊性质：**
 - 若m,n互质，φ(mn) = φ(m)xφ(n)
 - 若n为质数则，φ(n) = n-1

3.求E
E是随机选取的一个数，满足两个条件：1<E<L；E和L的最大公约数为1

4.求D
D必须满足：
- 1 < D < L
- E*D mod L = 1

也就是满足乘法逆元E*D≡1(mod L)
D为E关于1模L的乘法逆元

![image](http://91wxk.cn/usr/uploads/2021/04/483640440.png)

**Windows下yafu安装及使用**

下载链接：https://sourceforge.net/projects/yafu/

使用方法：
1在yafu目录下使用cmd指令

2输入yafu-x64
 命令：factor(n)—— n 为需要分解的大数
 
**注意：若n位数过长,将n值保存在文本文档里，最后一定要有换行符**

    yafu-x64 "factor(@)" -batchfile test.txt
其中test.txt为保存需分解的大质数的文本文档

**使用python来进行RSA加密解密**

    import gmpy2
    N = 103461035900816914121390101299049044413950405173712170434161686539878160984549
    E = 65537
    p = 282164587459512124844245113950593348271
    q = 366669102002966856876605669837014229419
    L = (p-1)*(q-1)
    D = int(gmpy2.invert(E, L))
    '''
    gmpy2.invert()返回值类型为<class 'mpz'>
    invert(x,y)  计算 x 关于1模 y 的乘法逆元
    '''
    enstr = 0xad939ff59f6e70bcbfad406f2494993757eee98b91bc244184a377520d06fc35
    destr = gmpy2.powmod(enstr, D, N)
    '''
    gmpy2.powmod()返回值类型为<class 'mpz'>
    gmpy2.powmod(x,y,z)，计算x^y mod z 的值并返回
    '''
    flag0 = hex(destr)[2:]     # flag0类型为str，存的是十六进制表示的字符串
    flag1 = bytes.fromhex(flag0)  # 将其从十六进制转换为byte类型(此时已解释成字符)
    flag = str(flag1, 'utf-8')  # 将byte类型转换为str类型
    print(flag)
